using Azure.AI.OpenAI;
using Crazor.AdaptiveCards;
using Crazor.AI.Recognizers;
using Crazor.Teams;
using Microsoft.Bot.Builder;
using Microsoft.Extensions.Configuration;
using Microsoft.Recognizers.Text.Choice;
using Microsoft.Recognizers.Text.DataTypes.TimexExpression;
using Microsoft.Recognizers.Text.DateTime;
using Microsoft.Recognizers.Text.Number;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Schema;
using Newtonsoft.Json.Schema.Generation;
using System.Text.RegularExpressions;
using System.Text;
using YamlConverter;
using Crazor.AI.Attributes;
using System.Collections;
using Crazor.Attributes;
using System.ComponentModel.DataAnnotations;
using Crazor.Blazor;
using Microsoft.AspNetCore.Components;
using Microsoft.Bot.Schema;
using Humanizer;
using System;

namespace Crazor.AI
{
    public partial class FormCardView<CardAppT, ModelT> : CardView<CardAppT, ModelT>
        where CardAppT : CardApp
        where ModelT : class
    {
        private static Random _rnd = new Random();

        public FormCardView()
        {
            var gen = new JSchemaGenerator();
            gen.GenerationProviders.Add(new StringEnumGenerationProvider());

            this.Schema = gen.Generate(typeof(ModelT));
        }

        [Inject]
        public IConfiguration Configuration { get; set; }

        [Inject]
        public FormRecognizer Recognizer { get; set; }

        public string Name { get; set; }

        [TempMemory]
        protected JSchema Schema { get; set; } = new JSchema();

        [TempMemory]
        public bool HasApproval { get; set; } = false;

        /// <summary>
        /// This will be called when all requirements for API have been met and confirmed.
        /// </summary>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        public async virtual Task<APIResult> OnFormReady(CancellationToken cancellationToken = default)
        {
            // NOTE: this default implementation simply gathers up all properties from memory and returns it with empty result.
            // var message = await GetSuccessResponseMessage(this, cancellationToken);
            string message = "Form is ready";
            var apiResult = new APIResult(this.Name, this, message);
            return apiResult;
        }


        #region functions

        public virtual async Task OnCopilot(string copilotText, CancellationToken cancellationToken)
        {
            if (!String.IsNullOrEmpty(copilotText))
            {
                // recognize...
                var result = await Recognizer.RecognizeAsync(this.Model, copilotText, cancellationToken);
                var (intent, score) = result.GetTopScoringIntent();

                if (intent == FunctionsRecognizer.FUNCTIONS_INTENT)
                {
                    await OnFunctionsIntent(result, cancellationToken);
                }
                else
                {
                    await OnUnrecognizedIntentAsync(result, cancellationToken);
                }
            }
        }

        protected async virtual Task OnUnrecognizedIntentAsync(RecognizerResult recognizerResult, CancellationToken cancellationToken)
        {
            AddBannerMessage(this.BindFormTemplate<NotUnderstoodTemplateAttribute>(new KeyValuePair<string, object?>("utterance", recognizerResult.Text)), AdaptiveContainerStyle.Attention);
            await this.OnEvaluateStateAsync(cancellationToken);
        }

        /// <summary>
        /// OnFunctionsIntent - Processes List of functions generated by recognition phase.
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="messageActivity"></param>
        /// <param name="recognizerResult"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task OnFunctionsIntent(RecognizerResult recognizerResult, CancellationToken cancellationToken)
        {
            var functions = JToken.FromObject(recognizerResult.Entities[FunctionsRecognizer.FUNCTIONS_INTENT]).ToObject<List<Function>>();

            // it's possible to get a CHANGE(property) and ASSIGN(property, value) in same recognition.  If we have an assignment we can drop the CHANGE()
            foreach (var changeFunction in functions.Where(function => function.Name == FormFunctions.CHANGE).ToList())
            {
                if (functions.Any(c => c.Name == FormFunctions.ASSIGN && c.Args.FirstOrDefault()?.ToString() == changeFunction.Args.FirstOrDefault()?.ToString()))
                {
                    functions.Remove(changeFunction);
                }
            }

            // execute each function, culling out empty responses. 
            foreach (var afunction in functions)
            {
                foreach (var function in ExpandArgs(afunction))
                {
                    await ExecuteFunction(function, cancellationToken);
                }
            }

            await OnEvaluateStateAsync(cancellationToken);
        }


        public async virtual Task ExecuteFunction(Function function, CancellationToken cancellationToken = default)
        {
            switch (function.Name)
            {
                case FormFunctions.ASSIGN:
                    await OnAssignPropertyAsync(GetPropertyForLabel(function.Args.FirstOrDefault()?.ToString()), function.Args.Skip(1).FirstOrDefault(), cancellationToken);
                    break;
                case FormFunctions.VALUE:
                    await OnValueAsync(function.Args.FirstOrDefault()?.ToString(), cancellationToken);
                    break;
                case FormFunctions.CLEAR:
                    await OnClearPropertyAsync(GetPropertyForLabel(function.Args.FirstOrDefault()?.ToString()), cancellationToken);
                    break;
                case FormFunctions.REMOVE:
                    await OnRemoveValueAsync(GetPropertyForLabel(function.Args.FirstOrDefault()?.ToString()), function.Args.Skip(1).FirstOrDefault(), cancellationToken);
                    break;
                case FormFunctions.CHANGE:
                    await OnChangePropertyAsync(GetPropertyForLabel(function.Args.FirstOrDefault()?.ToString()), cancellationToken);
                    break;
                case FormFunctions.QUESTION:
                    await OnQuestionAsync(GetPropertyForLabel(function.Args.FirstOrDefault()?.ToString()), cancellationToken);
                    break;
                case FormFunctions.CANCEL:
                    await OnCancelFormAsync(cancellationToken);
                    break;
                case FormFunctions.RESET:
                    await OnResetFormAsync(cancellationToken);
                    break;
                case FormFunctions.APPROVAL:
                    await OnApprovalAsync(function.Args.FirstOrDefault()?.ToString(), cancellationToken);
                    break;
                case FormFunctions.OPTIONS:
                    await OnOptionsAsync(GetPropertyForLabel(function.Args.FirstOrDefault()?.ToString()), cancellationToken);
                    break;
                case FormFunctions.SHOW:
                    await OnShowFormAsync(cancellationToken);
                    break;
                case FormFunctions.SHOWPROPERTY:
                    await OnShowPropertyAsync(GetPropertyForLabel(function.Args.FirstOrDefault()?.ToString()), cancellationToken);
                    break;
                case FormFunctions.FORMREADY:
                    await OnFormReadyFunctionAsync(cancellationToken);
                    break;
                default:
                    AddBannerMessage($"{function.Name} is not implemented");
                    break;
            }
        }

        /// <summary>
        /// ASSIGN(property, value) 
        /// </summary>
        /// <remarks>This processes a function to try to assign a value to a property in memory.</remarks>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task OnAssignPropertyAsync(string? property, object? value, CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;

            // if the property is not in the schema.
            if (!Schema.Properties.TryGetValue(property, out var propSchema))
            {
                // add UNKNOWNPROPERTY(property) response.
                // AddBannerMessage(BindFormTemplate<UnknownPropertyTemplateAttribute>(property));
                return;
            }

            // see if value matches property schema
            var (newValue, errorResponse) = await ValidatePropertyValue(property, value?.ToString());
            if (errorResponse != null)
            {
                AddBannerMessage(errorResponse, AdaptiveContainerStyle.Warning);
                return;
            }

            // no value
            if (newValue != null)
            {
                // actually assign the value
                await AssignValueAsync(property, newValue, cancellationToken);
            }

            return;
        }

        /// <summary>
        /// Actually assign the value to the property
        /// </summary>
        /// <remarks>This is callaed after the value has been validated</remarks>
        /// <param name="dc"></param>
        /// <param name="property"></param>
        /// <param name="value"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task AssignValueAsync(string? property, object? value, CancellationToken cancellationToken = default)
        {
            if (!Schema.Properties.TryGetValue(property, out var propSchema))
            {
                // add UNKNOWNPROPERTY(property) response.
                // AddBannerMessage(BindTemplate(Templates.UnknownProperty, property));
                return;
            }

            var propertyInfo = typeof(ModelT).GetProperty(property);

            // If it's an array then we process the value as "add" operation
            if (propSchema.Type == JSchemaType.Array)
            {
                var collection = (IList)propertyInfo.GetValue(this.Model);
                collection.Add(value);

                // add ADDED(value) response
                AddBannerMessage(BindPropertyTemplate<ValueAddedTemplateAttribute>(property), AdaptiveContainerStyle.Good);
                return;
            }

            // get old value if any
            ObjectPath.TryGetPathValue<object?>(this.Model, property, out var oldValue);

            // if it changed
            if (string.Compare(value?.ToString(), oldValue?.ToString(), ignoreCase: true) != 0)
            {
                // set the new value
                ObjectPath.SetPathValue(this.Model, property, value);

                // if old value was not null
                if (oldValue != null)
                {
                    // add CHANGED(value) response
                    AddBannerMessage(BindPropertyTemplate<ValueChangedTemplateAttribute>(property, new KeyValuePair<string, object?>("oldValue", oldValue)), AdaptiveContainerStyle.Good);
                }
                else
                {
                    // add ASSIGNED(value) response
                    AddBannerMessage(BindPropertyTemplate<ValueAssignedTemplateAttribute>(property), AdaptiveContainerStyle.Good);
                }
            }
            return;
        }

        protected virtual async Task OnValueAsync(object? value, CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;
            // I DONT THINK WE NEED THIS

            //if (expectedProperty != null)
            //{
            //    return await OnAssignPropertyAsync(expectedProperty, value, cancellationToken);
            //}
            //return await OnRecognizedIntentAsync(dc.Context.Activity, null, cancellationToken);
        }

        /// <summary>
        /// CLEAR(property) function - remove property value
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task OnClearPropertyAsync(string? property, CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;

            if (property != null)
            {
                // add REMOVED(property) response
                if (!Schema.Properties.ContainsKey(property))
                {
                    // AddBannerMessage(BindTemplate(Templates.UnknownProperty, property, null));
                }
                else
                {
                    ObjectPath.RemovePathValue(this.Model, property);
                    AddBannerMessage(BindPropertyTemplate<ValueClearedTemplateAttribute>(property), AdaptiveContainerStyle.Good);
                }
            }
        }

        /// <summary>
        /// REMOVE(property) function
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task OnRemoveValueAsync(string? property, object? value, CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;

            if (!Schema.Properties.TryGetValue(property, out var propSchema))
            {
                // add UNKNOWNPROPERTY(property) response.
                // AddBannerMessage(BindTemplate(Templates.UnknownProperty, property));
                return;
            }

            // If it's an array then we process the value as "add" operation
            if (propSchema.Type == JSchemaType.Array)
            {
                var collection = (IList)ObjectPath.GetPathValue<IList<object?>>(this.Model, property);
                collection.Remove(value);

                // add ADDED(value) response
                AddBannerMessage(BindPropertyTemplate<ValueRemovedTemplateAttribute>(property), AdaptiveContainerStyle.Good);
                return;
            }
        }

        /// <summary>
        /// CHANGE(property) - request to change a property without the value.
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task OnChangePropertyAsync(string? property, CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;

            if (property != null)
            {
                // add ASK(property) response
                //if (!dc.State.GetBoolValue($"this._asked.{property}"))
                //{
                //    await OnOptionsAsync(property, cancellationToken);
                //    dc.State.SetValue($"this._asked.{property}", true); // set to null so we can ask again (if needed
                //}
                //AddAskResponse(BindTemplate(Templates.Properties[property.ToString()].Ask, property, null), property);
            }
        }

        /// <summary>
        /// QUESTION(questionText) - question by user that we will reflect back into the output for GPT to answer.
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task OnQuestionAsync(string? question, CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;

            // Add question response with the users' question in it.
            // AddQuestionResponse(question);
        }

        /// <summary>
        /// APPROVAL(value) - a confirmation was detected. This sets this._confirmation=value
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task OnApprovalAsync(string? arg, CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;

            //if (arg != null)
            //{
            //    var result = ChoiceRecognizer.RecognizeBoolean(arg, "en");

            //    if (result[0].TypeName == "boolean")
            //    {
            //        var confirmation = (bool?)result[0].Resolution.FirstOrDefault(r => r.Key == "value").Value;
            //        if (confirmation != null)
            //        {
            //            this.HasApproval = confirmation.Value;
            //        }
            //    }
            //}
        }

        /// <summary>
        /// CANCEL() - request by the user to cancel the dialog
        /// </summary>
        /// <remarks>
        /// This will push the function into PENDING_COMMAND and ask for confirmation.  When it is executed again with confirmation it ends the dialog.
        /// </remarks>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task OnCancelFormAsync(CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;
            //var confirmation = dc.State.GetValue<bool?>(CONFIRMATION);
            //if (confirmation != null)
            //{
            //    dc.State.RemoveValue(CONFIRMATION);
            //    dc.State.RemoveValue(COMMAND_PENDING_CONFIRMATION);

            //    if (confirmation.Value)
            //    {
            //        // we have confirmation
            //        var apiResult = new APIResult(Name, null, "canceled", suceeded: false);
            //        return await dc.CancelDialogAsync(apiResult, cancellationToken);
            //    }

            //    // cancellation canceled.
            //    return null;
            //}

            //// queue the function
            //dc.State.SetValue(COMMAND_PENDING_CONFIRMATION, new Function() { Name = FormFunctions.CANCEL });

            //// Add ASK(confirmation) response
            //AddAskResponse(BindTemplate(Templates.ConfirmCancel, Name, Description));
            //return null;
        }

        /// <summary>
        /// Function for submitting form 
        /// </summary>
        /// <remarks>
        /// This will push the function into PENDING_COMMAND and ask for confirmation.  When it is executed again with confirmation it Calls the API And ends the dialog.
        /// </remarks>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        private async Task OnFormReadyFunctionAsync(CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;
        }

        /// <summary>
        /// RESET() - user has requested to start over with the task.
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task OnResetFormAsync(CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;
        }

        /// <summary>
        /// SHOW() - request by the user to show the form data
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected async Task OnShowFormAsync(CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;
        }

        /// <summary>
        /// SHOWPROPERTY(property)
        /// </summary>
        /// <remarks>Describes the current value for a property.</remarks>
        /// <param name="dc"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected async Task OnShowPropertyAsync(string property, CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;
        }

        /// <summary>
        /// Help(Property?) - request by the user for help for a property (or form)
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected async Task OnOptionsAsync(string? property, CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;
        }
        #endregion


        /// <summary>
        /// Evaluate state and decide if we need to ask any questions, confirm, etc.
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        public async virtual Task OnEvaluateStateAsync(CancellationToken cancellationToken)
        {
            bool hasAllRequired = true;

            //// figure out if we have have an external dependency we need to change view for.
            //foreach (var property in Model.GetType().GetProperties())
            //{
            //    if (!ObjectPath.HasValue(this.Model, property.Name))
            //    {
            //        if (property.GetCustomAttributes(typeof(RequiredAttribute), true).Any())
            //        {
            //            hasAllRequired = false;
            //            break;
            //        }
            //    }

            //    {
            //        if (property.GetValue(Model) == null)
            //        {
            //            hasAllRequired = false;
            //            break;
            //        }
            //    }
            //}

            //foreach (var requiredPropertyName in Schema.Required)
            //{
            //    if (!ObjectPath.HasValue(this.Model, requiredPropertyName))
            //    {
            //        // we don't
            //        hasAllRequired = false;
            //        break;
            //    }
            //}

            //// If we have all required properties and there are no ASKS pending
            //if (hasAllRequired && !responses.Any(response => response.ResponseType == ResponseType.Ask))
            //{
            //    // call OnFormReady (this will ask for confirmation if needed, and then CallAPI() )
            //    var dialogResult = await OnFormReadyFunctionAsync(cancellationToken);

            //    // if we have a dialog result (canceled or result) return it.
            //    if (dialogResult != null)
            //    {
            //        return dialogResult;
            //    }
            //}
        }

        #region helpers
        /// <summary>
        /// Bind args to a template. If there are multiple templates, pick one at random.
        /// </summary>
        /// <param name="alternatives">collection of alternatives to bind to</param>
        /// <param name="args"></param>
        /// <returns></returns>
        protected string BindPropertyTemplate<TextResponseTemplateAttributeT>(string property, params KeyValuePair<string, object?>[] args)
            where TextResponseTemplateAttributeT : ActionTemplateAttribute
        {
            var propertyInfo = this.Model.GetType().GetProperty(property);
            var attributes = propertyInfo.GetCustomAttributes(typeof(TextResponseTemplateAttributeT), true)?.ToList();
            IResponseTemplate responseTemplate;
            if (attributes != null && attributes.Any())
            {
                responseTemplate = (IResponseTemplate)attributes[_rnd.Next(attributes.Count - 1)];
            }
            else
            {
                responseTemplate = Activator.CreateInstance<TextResponseTemplateAttributeT>();
            }

            var value = propertyInfo.GetValue(this.Model);
            Dictionary<string, object?> data = new Dictionary<string, object?>(args)
            {
                { "$property", property },
                { "$value", propertyInfo.GetValue(this.Model) },
                { "property", this.GetPropertyLabel(property) },
                { "value", this.GetPropertyValueFormated(property, value) },
                { "form", this },
                { "model", this.GetModel() }
            };
            return responseTemplate.BindTemplate(data);
        }

        /// <summary>
        /// Bind args to a template. If there are multiple templates, pick one at random.
        /// </summary>
        /// <param name="alternatives">collection of alternatives to bind to</param>
        /// <param name="args"></param>
        /// <returns></returns>
        protected string BindFormTemplate<TextResponseTemplateAttributeT>(params KeyValuePair<string, object?>[] args)
            where TextResponseTemplateAttributeT : ActionTemplateAttribute
        {
            var attributes = this.GetType().GetCustomAttributes(typeof(TextResponseTemplateAttributeT), true)?.ToList();
            IResponseTemplate responseTemplate;
            if (attributes != null && attributes.Any())
            {
                responseTemplate = (IResponseTemplate)attributes[_rnd.Next(attributes.Count - 1)];
            }
            else
            {
                responseTemplate = Activator.CreateInstance<TextResponseTemplateAttributeT>();
            }

            Dictionary<string, object?> data = new Dictionary<string, object?>(args)
            {
                { "form", this },
                { "model", this.GetModel() }
            };
            return responseTemplate.BindTemplate(data);
        }

        /// <summary>
        /// For functions that can accept an array of args expand into multiple functions.
        /// </summary>
        protected List<Function> ExpandArgs(Function function)
        {
            var functions = new List<Function>();
            if ((function.Name == FormFunctions.ASSIGN || function.Name == FormFunctions.REMOVE) && function.Args.Skip(1).FirstOrDefault() is JArray jfunction)
            {
                var property = function.Args.FirstOrDefault();
                foreach (var arg in jfunction)
                {
                    functions.Add(new Function { Name = function.Name, Args = new List<object> { property, arg } });
                }
            }
            else
            {
                functions.Add(function);
            }
            return functions;
        }

        /// <summary>
        /// ValidateValue
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="property"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public virtual async Task<(object? value, string? errors)> ValidatePropertyValue(string? property, string? value)
        {
            await Task.CompletedTask;

            object? result = null;
            if (property == null)
            {
                return (result, null);
            }

            // Convert to a valid instance of the schema type
            var (newValue, errors) = ToSchemaType(property, value);
            if (errors != null)
            {
                return (null, errors);
            }
            return (newValue, null);
        }

        /// <summary>
        /// Normalize a string value for case and ending.
        /// </summary>
        protected string Normalize(string input)
        {
            var value = input.Trim().ToLowerInvariant();
            if (value.EndsWith('s'))
            {
                value = value.Substring(0, value.Length - 1);
            }
            return value;
        }


        /// <summary>
        /// Convert string value to the desired schema type and validate it.
        /// </summary>
        /// <param name="value">Recognizer string value.</param>
        /// <param name="property">Property name.</param>
        /// <returns>The resulting value, the expected type and any validation errors.</returns>
        /// <remarks>
        /// If there are validation errors then we would convert but the result did not match json schema validation.
        /// If the value is null and there is no type, then the property did not exist.
        /// </remarks>
        protected (object?, string?) ToSchemaType(string? property, string? value)
        {
            // Convert value to the appropriate JSON type
            // This is fixed because we ask GPT to translate.
            // var locale = dc.State.GetStringValue($"conversation.locale", "en-us");
            var locale = "en-us";

            object? result = null;
            JSchemaType? eltType = null;
            var noType = $"Unknown {property}";
            if (property == null)
            {
                return (result, noType);
            }

            if (value == null || !Schema.Properties.TryGetValue(property, out var pschema))
            {
                return (result, noType);
            }

            var isArray = false;
            if (pschema.Type == null && pschema.OneOf.Any())
                pschema = pschema.OneOf.FirstOrDefault();
            eltType = pschema.Type;
            if (eltType == JSchemaType.Array)
            {
                pschema = pschema.Items?.FirstOrDefault();
                isArray = true;
                eltType = pschema?.Type;
            }
            if (pschema == null)
            {
                return (null, noType);
            }

            // Figure out base time for references
            var refDate = DateTime.Now;
            //if (pschema.ExtensionData.TryGetValue(REF_DATE, out var refDateProperty))
            //{
            //    // TODO: In theory we should probably order the ref property before the current one.  
            //    // In English though it is likely the order will be right anyway so punt for now.
            //    var date = dc.State.GetStringValue($"form.{refDateProperty.Value<string>()}");
            //    if (date != null && DateTime.TryParse(date, out var dateValue))
            //    {
            //        refDate = dateValue;
            //    }
            //}

            switch (eltType)
            {
                case JSchemaType.String:
                    switch (pschema?.Format)
                    {
                        case "date":
                            {
                                var (type, _timex, dvalue) = RecognizeDateTime(pschema, value, locale, refDate);
                                if (type == "date")
                                {
                                    result = dvalue;
                                }
                            }
                            break;
                        case "time":
                            {
                                var (type, _timex, dvalue) = RecognizeDateTime(pschema, value, locale, refDate);
                                if (type == "time")
                                {
                                    result = dvalue;
                                }
                            }
                            break;
                        case "datetime":
                        case "date-time":
                            {
                                var (type, timex, _dvalue) = RecognizeDateTime(pschema, value, locale, refDate);
                                if (type == "datetime" && timex != null)
                                {
                                    var colons = timex.Count(c => c == ':');
                                    if (colons == 0)
                                    {
                                        timex += ":00:00";
                                    }
                                    else if (colons == 1)
                                    {
                                        timex += ":00";
                                    }
                                    result = timex;
                                }
                                else if (type == "date")
                                {
                                    result = Convert.ToDateTime(_dvalue);
                                }
                                else if (type == "time")
                                {
                                    result = Convert.ToDateTime(_dvalue);
                                }
                            }
                            break;
                        case "duration":
                            {
                                var (type, timex, _dvalue) = RecognizeDateTime(pschema, value, locale, refDate);
                                TimexProperty timexProperty = new TimexProperty(timex);
                            }
                            break;
                        default:
                            {
                                var enumChoices = pschema!.Enum;
                                if (enumChoices.Any())
                                {
                                    var nvalue = Normalize(value);
                                    var wordCount = -1;
                                    List<string>? wordMatches = null;
                                    foreach (var jchoice in enumChoices)
                                    {
                                        var choice = jchoice.ToString();
                                        if (choice.ToLowerInvariant() == nvalue)
                                        {
                                            result = choice;
                                            break;
                                        }
                                        else
                                        {
                                            // Break on case changes and normalize
                                            var words = from word in Regex.Split(choice, @"(?<!^)(?=\p{Lu})") select Normalize(word);
                                            var phrase = string.Join(' ', words);
                                            if (phrase == nvalue)
                                            {
                                                result = choice;
                                                break;
                                            }
                                            else
                                            {
                                                // Count word matches for partial matches
                                                var count = 0;
                                                foreach (var word in words)
                                                {
                                                    if (nvalue.Contains(word))
                                                    {
                                                        ++count;
                                                    }
                                                }
                                                if (count == wordCount)
                                                {
                                                    wordMatches!.Add(choice);
                                                }
                                                else if (count > 0 && count > wordCount)
                                                {
                                                    wordCount = count;
                                                    wordMatches = new List<string> { choice };
                                                }
                                            }
                                        }
                                    }
                                    if (wordMatches != null && wordMatches.Count == 1)
                                    {
                                        // Partial match of one choice
                                        result = wordMatches.First();
                                    }
                                }
                                else
                                {
                                    result = value;
                                }
                            }
                            break;
                    }
                    break;
                case JSchemaType.Boolean:
                    {
                        if (bool.TryParse(value, out var bvalue))
                        {
                            result = bvalue;
                        }
                        break;
                    }
                case JSchemaType.Integer:
                    {
                        if (int.TryParse(value, out var ivalue))
                        {
                            result = ivalue;
                        }
                        else
                        {
                            var number = RecognizeNumber(value, locale);
                            if (number is int)
                            {
                                result = number;
                            }
                        }
                    }
                    break;
                case JSchemaType.Number:
                    {
                        if (double.TryParse(value, out var dvalue))
                        {
                            result = dvalue;
                        }
                        else
                        {
                            result = RecognizeNumber(value, "en-us");
                        }
                    }
                    break;
                default:
                    break;
            }
            if (result == null)
            {
                return (null, $"{value} is not valid for {GetPropertyLabel(property)}");
            }

            IList<ValidationError> errors = new List<ValidationError>();
            var isValid = JToken.FromObject(result).IsValid(pschema, out errors);
            if (!isValid)
            {
                return (null, $"{value} is not valid for {GetPropertyLabel(property)} because: {string.Join(',', errors.Select(e => e.Message))}");
            }

            if (pschema.Type == JSchemaType.String && pschema.Format == "phone")
            {
                var model = Microsoft.Recognizers.Text.Sequence.SequenceRecognizer.RecognizePhoneNumber(result?.ToString(), "en");
                if (model.Count != 1)
                {
                    return (null, $"{value} is not valid for {GetPropertyLabel(property)}");
                }
                else
                {
                    result = model[0].Resolution["value"].ToString();
                }
            }


            return (result, null);
        }

        static protected (string? type, string? timex, string? value) RecognizeDateTime(JSchema schema, string value, string locale, DateTime refDate)
        {
            DateTime min = DateTime.MinValue;
            DateTime max = DateTime.MaxValue;
            if (schema.ExtensionData.TryGetValue("$minimum", out var minVal))
            {
                min = minVal.ToString() == "$NOW" ? new DateTime(DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day) : DateTime.Parse(minVal.ToString());
            }

            if (schema.ExtensionData.TryGetValue("$maximum", out var maxVal))
            {
                max = maxVal.ToString() == "$NOW" ? new DateTime(DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day, 23, 55, 55) : DateTime.Parse(maxVal.ToString());
            }

            var results = DateTimeRecognizer.RecognizeDateTime(value, locale, refTime: refDate).FirstOrDefault();
            if (results == null)
            {
                results = NumberRecognizer.RecognizeOrdinal(value, locale).FirstOrDefault();
                if (results != null)
                {
                    results = DateTimeRecognizer.RecognizeDateTime($"on the {value}", "en-us", refTime: refDate).FirstOrDefault();
                }
            }

            if (results != null)
            {
                if ((results.End - results.Start) < value.Length / 2)
                {
                    return (null, null, null);
                }

                foreach (var resolution in results?.Resolution["values"] as List<Dictionary<string, string>>)
                {
                    switch (resolution["type"])
                    {
                        case "date":
                        case "date-time":
                        case "datetime":
                            var date = DateTime.Parse(resolution["value"]);
                            if (date >= min && date <= max)
                            {
                                return (resolution?["type"], resolution?["timex"], resolution?["value"]);
                            }
                            break;
                        case "time":
                            var time = TimeSpan.Parse(resolution["value"]);
                            if (time >= min.TimeOfDay && time <= max.TimeOfDay)
                            {
                                return (resolution?["type"], resolution?["timex"], resolution?["value"]);
                            }
                            break;
                        case "duration":
                            // TODO : Check duration constraints
                            return (resolution?["type"], resolution?["timex"], resolution?["value"]);
                    }
                }
            }
            return (null, null, null);
        }

        static protected object? RecognizeNumber(string value, string locale)
        {
            object? result = null;
            value = value.Trim();

            var models = NumberRecognizer.RecognizeNumber(value, locale);
            if (models.Count > 1)
            {
                return null;
            }
            var model = models.FirstOrDefault();
            if (model != null)
            {
                var subtype = model.Resolution["subtype"] as string;
                var svalue = model.Resolution["value"] as string;
                if (subtype != null && svalue != null)
                {
                    if (model.Start == 0 && model.End == 0)
                    {
                        model.Start = value.IndexOf(svalue);
                        model.End = svalue.Length;
                    }

                    if ((model.End - model.Start) >= value.Length / 2)
                    {

                        if (subtype == Microsoft.Recognizers.Text.Number.Constants.INTEGER)
                        {
                            if (int.TryParse(svalue, out var ivalue))
                            {
                                result = ivalue;
                            }
                        }
                        else
                        {
                            // DECIMAL, FRACTION or POWER
                            if (double.TryParse(svalue, out var dvalue))
                            {
                                result = dvalue;
                            }
                        }
                    }
                }
            }
            return result;
        }

        protected string GetPropertyLabel(string property)
        {
            var prop = Schema.Properties[property];
            if (prop.ExtensionData.TryGetValue("label", out var label))
            {
                return label.ToString().Humanize();
            }
            return property;
        }

        protected string GetPropertyForLabel(string property)
        {
            if (string.IsNullOrEmpty(property))
            {
                return null;
            }

            if (Schema.Properties.TryGetValue(property, out var _))
            {
                return property;
            }
            var prop = Schema.Properties.Where(p =>
            {
                if (p.Value.ExtensionData.TryGetValue("label", out var label))
                {
                    return string.Compare(label.ToString(), property, ignoreCase: true) == 0;
                }
                return false;
            }).Select(prop => prop.Key).FirstOrDefault();
            return prop ?? property;
        }

        protected string GetPropertyValueFormated(string propertyName, object? value)
        {
            if (this.Schema.Properties.TryGetValue(propertyName, out var property))
            {
                if (property.Type == JSchemaType.Array && property.Items != null)
                {
                    var item = property.Items.FirstOrDefault();
                    if (item != null && item.Type == JSchemaType.String && item.Enum != null)
                    {
                        if (!(value is JArray))
                            value = new JArray() { value };

                        return string.Join(", ", JArray.FromObject(value).Select(v =>
                        {
                            if (item.ExtensionData.TryGetValue("EnumLabels", out var enumLabels))
                            {
                                var labels = enumLabels as JArray;
                                if (labels != null)
                                {
                                    var index = item.Enum.IndexOf(v?.ToString());
                                    if (index >= 0 && index < labels.Count)
                                    {
                                        return labels[index].ToString();
                                    }
                                }
                            }
                            return v.ToString().Humanize();
                        }));
                    }
                }
            }
            return value?.ToString();
        }
        #endregion    
    }
}
