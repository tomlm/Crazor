using Crazor.AdaptiveCards;
using Crazor.AI.Recognizers;
using Microsoft.Bot.Builder;
using Microsoft.Extensions.Configuration;
using Microsoft.Recognizers.Text.DataTypes.TimexExpression;
using Microsoft.Recognizers.Text.DateTime;
using Microsoft.Recognizers.Text.Number;
using Newtonsoft.Json.Linq;
using Crazor.AI.Attributes;
using System.Collections;
using Crazor.Attributes;
using Crazor.Blazor;
using Microsoft.AspNetCore.Components;
using Microsoft.Recognizers.Text.Choice;
using System.Reflection;
using System.ComponentModel.DataAnnotations;

namespace Crazor.AI
{
    public partial class FormCardView<CardAppT, ModelT> : CardView<CardAppT, ModelT>
        where CardAppT : CardApp
        where ModelT : class
    {
        private static Random _rnd = new Random();

        public FormCardView()
        {
            //var gen = new JSchemaGenerator();
            //gen.GenerationProviders.Add(new StringEnumGenerationProvider());

            //this.Schema = gen.Generate(typeof(ModelT));
        }

        [Inject]
        public IConfiguration Configuration { get; set; }

        [Inject]
        public FormRecognizer Recognizer { get; set; }

        public string Name { get; set; }

        [TempMemory]
        public bool HasApproval { get; set; } = false;

        /// <summary>
        /// This will be called when all requirements for API have been met and confirmed.
        /// </summary>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        public async virtual Task<APIResult> OnFormReady(CancellationToken cancellationToken = default)
        {
            // NOTE: this default implementation simply gathers up all properties from memory and returns it with empty result.
            // var message = await GetSuccessResponseMessage(this, cancellationToken);
            string message = "Form is ready";
            var apiResult = new APIResult(this.Name, this, message);
            return apiResult;
        }


        #region functions

        public virtual async Task OnCopilot(string copilotText, CancellationToken cancellationToken)
        {
            if (!String.IsNullOrEmpty(copilotText))
            {
                // recognize...
                var result = await Recognizer.RecognizeAsync(this.Model, copilotText, cancellationToken);
                var (intent, score) = result.GetTopScoringIntent();

                if (intent == FunctionsRecognizer.FUNCTIONS_INTENT)
                {
                    await OnFunctionsIntent(result, cancellationToken);
                }
                else
                {
                    await OnUnrecognizedIntentAsync(result, cancellationToken);
                }
            }
        }

        protected async virtual Task OnUnrecognizedIntentAsync(RecognizerResult recognizerResult, CancellationToken cancellationToken)
        {
            AddBannerMessage(this.BindFormTemplate<NotUnderstoodTemplateAttribute>(new KeyValuePair<string, object?>("utterance", recognizerResult.Text)), AdaptiveContainerStyle.Attention);
            await this.OnEvaluateStateAsync(cancellationToken);
        }

        /// <summary>
        /// OnFunctionsIntent - Processes List of functions generated by recognition phase.
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="messageActivity"></param>
        /// <param name="recognizerResult"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task OnFunctionsIntent(RecognizerResult recognizerResult, CancellationToken cancellationToken)
        {
            var functions = JToken.FromObject(recognizerResult.Entities[FunctionsRecognizer.FUNCTIONS_INTENT]).ToObject<List<Function>>();

            // it's possible to get a CHANGE(property) and ASSIGN(property, value) in same recognition.  If we have an assignment we can drop the CHANGE()
            foreach (var changeFunction in functions.Where(function => function.Name == FormFunctions.CHANGE).ToList())
            {
                if (functions.Any(c => c.Name == FormFunctions.ASSIGN && c.Args.FirstOrDefault()?.ToString() == changeFunction.Args.FirstOrDefault()?.ToString()))
                {
                    functions.Remove(changeFunction);
                }
            }

            // execute each function, culling out empty responses. 
            foreach (var afunction in functions)
            {
                foreach (var function in ExpandArgs(afunction))
                {
                    await ExecuteFunction(function, cancellationToken);
                }
            }

            await OnEvaluateStateAsync(cancellationToken);
        }


        public async virtual Task ExecuteFunction(Function function, CancellationToken cancellationToken = default)
        {
            switch (function.Name)
            {
                case FormFunctions.ASSIGN:
                    await OnAssignPropertyAsync(GetPropertyForLabel(function.Args.FirstOrDefault()?.ToString()), function.Args.Skip(1).FirstOrDefault(), cancellationToken);
                    break;
                case FormFunctions.VALUE:
                    await OnValueAsync(function.Args.FirstOrDefault()?.ToString(), cancellationToken);
                    break;
                case FormFunctions.CLEAR:
                    await OnClearPropertyAsync(GetPropertyForLabel(function.Args.FirstOrDefault()?.ToString()), cancellationToken);
                    break;
                case FormFunctions.REMOVE:
                    await OnRemoveValueAsync(GetPropertyForLabel(function.Args.FirstOrDefault()?.ToString()), function.Args.Skip(1).FirstOrDefault(), cancellationToken);
                    break;
                case FormFunctions.CHANGE:
                    await OnChangePropertyAsync(GetPropertyForLabel(function.Args.FirstOrDefault()?.ToString()), cancellationToken);
                    break;
                case FormFunctions.QUESTION:
                    await OnQuestionAsync(GetPropertyForLabel(function.Args.FirstOrDefault()?.ToString()), cancellationToken);
                    break;
                case FormFunctions.CANCEL:
                    await OnCancelFormAsync(cancellationToken);
                    break;
                case FormFunctions.RESET:
                    await OnResetFormAsync(cancellationToken);
                    break;
                case FormFunctions.APPROVAL:
                    await OnApprovalAsync(function.Args.FirstOrDefault()?.ToString(), cancellationToken);
                    break;
                case FormFunctions.OPTIONS:
                    await OnOptionsAsync(GetPropertyForLabel(function.Args.FirstOrDefault()?.ToString()), cancellationToken);
                    break;
                case FormFunctions.SHOW:
                    await OnShowFormAsync(cancellationToken);
                    break;
                case FormFunctions.SHOWPROPERTY:
                    await OnShowPropertyAsync(GetPropertyForLabel(function.Args.FirstOrDefault()?.ToString()), cancellationToken);
                    break;
                case FormFunctions.FORMREADY:
                    await OnFormReadyFunctionAsync(cancellationToken);
                    break;
                default:
                    AddBannerMessage($"{function.Name} is not implemented");
                    break;
            }
        }

        /// <summary>
        /// ASSIGN(property, value) 
        /// </summary>
        /// <remarks>This processes a function to try to assign a value to a property in memory.</remarks>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task OnAssignPropertyAsync(string? property, object? value, CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;

            //// if the property is not in the schema.
            //if (!Schema.Properties.TryGetValue(property, out var propSchema))
            //{
            //    // add UNKNOWNPROPERTY(property) response.
            //    // AddBannerMessage(BindFormTemplate<UnknownPropertyTemplateAttribute>(property));
            //    return;
            //}

            // see if value matches property schema
            var (newValue, errorResponse) = await ResolvePropertyValue(property, value?.ToString());
            if (errorResponse != null)
            {
                AddBannerMessage(errorResponse, AdaptiveContainerStyle.Warning);
                return;
            }

            // no value
            if (newValue != null)
            {
                // actually assign the value
                await AssignValueAsync(property, newValue, cancellationToken);
            }

            return;
        }

        /// <summary>
        /// Actually assign the value to the property
        /// </summary>
        /// <remarks>This is callaed after the value has been validated</remarks>
        /// <param name="dc"></param>
        /// <param name="property"></param>
        /// <param name="value"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task AssignValueAsync(string? property, object? value, CancellationToken cancellationToken = default)
        {
            if (!typeof(ModelT).TryGetPropertyInfo(property, out var propertyInfo))
            {
                // add UNKNOWNPROPERTY(property) response.
                // AddBannerMessage(BindTemplate(Templates.UnknownProperty, property));
                return;
            }

            // If it's an array then we process the value as "add" operation
            if (propertyInfo.PropertyType.IsList())
            {
                var collection = (IList)propertyInfo.GetValue(this.Model);
                collection.Add(value);

                // add ADDED(value) response
                AddBannerMessage(BindPropertyTemplate<ValueAddedTemplateAttribute>(property), AdaptiveContainerStyle.Good);
                return;
            }

            // get old value if any
            ObjectPath.TryGetPathValue<object?>(this.Model, property, out var oldValue);

            // if it changed
            if (string.Compare(value?.ToString(), oldValue?.ToString(), ignoreCase: true) != 0)
            {
                // set the new value
                this.Model.SetTargetProperty(propertyInfo, value);

                // if old value was not null
                if (oldValue != null)
                {
                    // add CHANGED(value) response
                    AddBannerMessage(BindPropertyTemplate<ValueChangedTemplateAttribute>(property, new KeyValuePair<string, object?>("oldValue", oldValue)), AdaptiveContainerStyle.Good);
                }
                else
                {
                    // add ASSIGNED(value) response
                    AddBannerMessage(BindPropertyTemplate<ValueAssignedTemplateAttribute>(property), AdaptiveContainerStyle.Good);
                }
            }
            return;
        }

        protected virtual async Task OnValueAsync(object? value, CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;
            // I DONT THINK WE NEED THIS

            //if (expectedProperty != null)
            //{
            //    return await OnAssignPropertyAsync(expectedProperty, value, cancellationToken);
            //}
            //return await OnRecognizedIntentAsync(dc.Context.Activity, null, cancellationToken);
        }

        /// <summary>
        /// CLEAR(property) function - remove property value
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task OnClearPropertyAsync(string? property, CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;

            if (typeof(ModelT).HasProperty(property))
            {
                ObjectPath.RemovePathValue(this.Model, property);
                AddBannerMessage(BindPropertyTemplate<ValueClearedTemplateAttribute>(property), AdaptiveContainerStyle.Good);
            }
        }

        /// <summary>
        /// REMOVE(property) function
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task OnRemoveValueAsync(string? property, object? value, CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;

            if (!typeof(ModelT).TryGetPropertyInfo(property, out var propertyInfo))
            {
                // add UNKNOWNPROPERTY(property) response.
                // AddBannerMessage(BindTemplate(Templates.UnknownProperty, property));
                return;
            }

            // If it's an array then we process the value as "add" operation
            if (propertyInfo.PropertyType.IsList())
            {
                var collection = (IList)propertyInfo.GetValue(this.Model);
                collection.Remove(value);

                // add ADDED(value) response
                AddBannerMessage(BindPropertyTemplate<ValueRemovedTemplateAttribute>(property), AdaptiveContainerStyle.Good);
                return;
            }
        }

        /// <summary>
        /// CHANGE(property) - request to change a property without the value.
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task OnChangePropertyAsync(string? property, CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;

            if (property != null)
            {
                // add ASK(property) response
                //if (!dc.State.GetBoolValue($"this._asked.{property}"))
                //{
                //    await OnOptionsAsync(property, cancellationToken);
                //    dc.State.SetValue($"this._asked.{property}", true); // set to null so we can ask again (if needed
                //}
                //AddAskResponse(BindTemplate(Templates.Properties[property.ToString()].Ask, property, null), property);
            }
        }

        /// <summary>
        /// QUESTION(questionText) - question by user that we will reflect back into the output for GPT to answer.
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task OnQuestionAsync(string? question, CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;

            // Add question response with the users' question in it.
            // AddQuestionResponse(question);
        }

        /// <summary>
        /// APPROVAL(value) - a confirmation was detected. This sets this._confirmation=value
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task OnApprovalAsync(string? arg, CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;

            //if (arg != null)
            //{
            //    var result = ChoiceRecognizer.RecognizeBoolean(arg, "en");

            //    if (result[0].TypeName == "boolean")
            //    {
            //        var confirmation = (bool?)result[0].Resolution.FirstOrDefault(r => r.Key == "value").Value;
            //        if (confirmation != null)
            //        {
            //            this.HasApproval = confirmation.Value;
            //        }
            //    }
            //}
        }

        /// <summary>
        /// CANCEL() - request by the user to cancel the dialog
        /// </summary>
        /// <remarks>
        /// This will push the function into PENDING_COMMAND and ask for confirmation.  When it is executed again with confirmation it ends the dialog.
        /// </remarks>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task OnCancelFormAsync(CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;
            //var confirmation = dc.State.GetValue<bool?>(CONFIRMATION);
            //if (confirmation != null)
            //{
            //    dc.State.RemoveValue(CONFIRMATION);
            //    dc.State.RemoveValue(COMMAND_PENDING_CONFIRMATION);

            //    if (confirmation.Value)
            //    {
            //        // we have confirmation
            //        var apiResult = new APIResult(Name, null, "canceled", suceeded: false);
            //        return await dc.CancelDialogAsync(apiResult, cancellationToken);
            //    }

            //    // cancellation canceled.
            //    return null;
            //}

            //// queue the function
            //dc.State.SetValue(COMMAND_PENDING_CONFIRMATION, new Function() { Name = FormFunctions.CANCEL });

            //// Add ASK(confirmation) response
            //AddAskResponse(BindTemplate(Templates.ConfirmCancel, Name, Description));
            //return null;
        }

        /// <summary>
        /// Function for submitting form 
        /// </summary>
        /// <remarks>
        /// This will push the function into PENDING_COMMAND and ask for confirmation.  When it is executed again with confirmation it Calls the API And ends the dialog.
        /// </remarks>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        private async Task OnFormReadyFunctionAsync(CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;
        }

        /// <summary>
        /// RESET() - user has requested to start over with the task.
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task OnResetFormAsync(CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;
        }

        /// <summary>
        /// SHOW() - request by the user to show the form data
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected async Task OnShowFormAsync(CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;
        }

        /// <summary>
        /// SHOWPROPERTY(property)
        /// </summary>
        /// <remarks>Describes the current value for a property.</remarks>
        /// <param name="dc"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected async Task OnShowPropertyAsync(string property, CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;
        }

        /// <summary>
        /// Help(Property?) - request by the user for help for a property (or form)
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="function"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected async Task OnOptionsAsync(string? property, CancellationToken cancellationToken = default)
        {
            await Task.CompletedTask;
        }
        #endregion


        /// <summary>
        /// Evaluate state and decide if we need to ask any questions, confirm, etc.
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        public async virtual Task OnEvaluateStateAsync(CancellationToken cancellationToken)
        {
            bool hasAllRequired = true;

            //// figure out if we have have an external dependency we need to change view for.
            //foreach (var property in Model.GetType().GetProperties())
            //{
            //    if (!ObjectPath.HasValue(this.Model, property.Name))
            //    {
            //        if (property.GetCustomAttributes(typeof(RequiredAttribute), true).Any())
            //        {
            //            hasAllRequired = false;
            //            break;
            //        }
            //    }

            //    {
            //        if (property.GetValue(Model) == null)
            //        {
            //            hasAllRequired = false;
            //            break;
            //        }
            //    }
            //}

            //foreach (var requiredPropertyName in Schema.Required)
            //{
            //    if (!ObjectPath.HasValue(this.Model, requiredPropertyName))
            //    {
            //        // we don't
            //        hasAllRequired = false;
            //        break;
            //    }
            //}

            //// If we have all required properties and there are no ASKS pending
            //if (hasAllRequired && !responses.Any(response => response.ResponseType == ResponseType.Ask))
            //{
            //    // call OnFormReady (this will ask for confirmation if needed, and then CallAPI() )
            //    var dialogResult = await OnFormReadyFunctionAsync(cancellationToken);

            //    // if we have a dialog result (canceled or result) return it.
            //    if (dialogResult != null)
            //    {
            //        return dialogResult;
            //    }
            //}
        }

        #region helpers
        /// <summary>
        /// Bind args to a template. If there are multiple templates, pick one at random.
        /// </summary>
        /// <param name="alternatives">collection of alternatives to bind to</param>
        /// <param name="args"></param>
        /// <returns></returns>
        protected string BindPropertyTemplate<TextResponseTemplateAttributeT>(string property, params KeyValuePair<string, object?>[] args)
            where TextResponseTemplateAttributeT : ActionTemplateAttribute
        {
            var propertyInfo = this.Model.GetType().GetProperty(property);
            var attributes = propertyInfo.GetCustomAttributes(typeof(TextResponseTemplateAttributeT), true)?.ToList();
            IResponseTemplate responseTemplate;
            if (attributes != null && attributes.Any())
            {
                responseTemplate = (IResponseTemplate)attributes[_rnd.Next(attributes.Count - 1)];
            }
            else
            {
                responseTemplate = Activator.CreateInstance<TextResponseTemplateAttributeT>();
            }

            var value = propertyInfo.GetValue(this.Model);
            Dictionary<string, object?> data = new Dictionary<string, object?>(args)
            {
                { "$property", property },
                { "$value", value },
                { "property", propertyInfo.GetPropertyLabel() },
                { "value", propertyInfo.GetFormatedValueText(value) },
                { "form", this },
                { "model", this.GetModel() }
            };
            return responseTemplate.BindTemplate(data);
        }

        /// <summary>
        /// Bind args to a template. If there are multiple templates, pick one at random.
        /// </summary>
        /// <param name="alternatives">collection of alternatives to bind to</param>
        /// <param name="args"></param>
        /// <returns></returns>
        protected string BindFormTemplate<TextResponseTemplateAttributeT>(params KeyValuePair<string, object?>[] args)
            where TextResponseTemplateAttributeT : ActionTemplateAttribute
        {
            var attributes = this.GetType().GetCustomAttributes(typeof(TextResponseTemplateAttributeT), true)?.ToList();
            IResponseTemplate responseTemplate;
            if (attributes != null && attributes.Any())
            {
                responseTemplate = (IResponseTemplate)attributes[_rnd.Next(attributes.Count - 1)];
            }
            else
            {
                responseTemplate = Activator.CreateInstance<TextResponseTemplateAttributeT>();
            }

            Dictionary<string, object?> data = new Dictionary<string, object?>(args)
            {
                { "form", this },
                { "model", this.GetModel() }
            };
            return responseTemplate.BindTemplate(data);
        }

        /// <summary>
        /// For functions that can accept an array of args expand into multiple functions.
        /// </summary>
        protected List<Function> ExpandArgs(Function function)
        {
            var functions = new List<Function>();
            if ((function.Name == FormFunctions.ASSIGN || function.Name == FormFunctions.REMOVE) && function.Args.Skip(1).FirstOrDefault() is JArray jfunction)
            {
                var property = function.Args.FirstOrDefault();
                foreach (var arg in jfunction)
                {
                    functions.Add(new Function { Name = function.Name, Args = new List<object> { property, arg } });
                }
            }
            else
            {
                functions.Add(function);
            }
            return functions;
        }

        /// <summary>
        /// Given a property and a value resolve the value to a valid value for the property or return errors
        /// </summary>
        /// <param name="dc"></param>
        /// <param name="property"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        public virtual async Task<(object? value, string? errors)> ResolvePropertyValue(string? property, string? value)
        {
            await Task.CompletedTask;

            object? result = null;
            if (property == null)
            {
                return (result, null);
            }

            // Convert to a valid instance of the schema type
            var (newValue, errors) = NormalizeValue(property, value);
            if (errors != null)
            {
                return (null, errors);
            }
            return (newValue, null);
        }

        /// <summary>
        /// Normalize a string value for case and ending.
        /// </summary>
        protected string Normalize(string input)
        {
            var value = input.Trim().ToLowerInvariant();
            if (value.EndsWith('s'))
            {
                value = value.Substring(0, value.Length - 1);
            }
            return value;
        }


        /// <summary>
        /// Convert string value to the desired schema type and validate it.
        /// </summary>
        /// <param name="value">Recognizer string value.</param>
        /// <param name="property">Property name.</param>
        /// <returns>The resulting value, the expected type and any validation errors.</returns>
        /// <remarks>
        /// If there are validation errors then we would convert but the result did not match json schema validation.
        /// If the value is null and there is no type, then the property did not exist.
        /// </remarks>
        protected (object?, string?) NormalizeValue(string? property, string? value)
        {
            // Convert value to the appropriate JSON type
            // This is fixed because we ask GPT to translate.
            // var locale = dc.State.GetStringValue($"conversation.locale", "en-us");
            var locale = "en-us";

            if (!typeof(ModelT).TryGetPropertyInfo(property, out var propertyInfo))
            {
                return (null, $"I didn't understand {property}");
            }

            var validationResults = new List<ValidationResult>();
            var context = new ValidationContext(this.Model)
            {
                MemberName = propertyInfo.Name,
                DisplayName = propertyInfo.GetPropertyLabel(),
            };

            var propertyType = propertyInfo.PropertyType;
            if (propertyInfo.PropertyType.IsList())
            {
                propertyType = propertyInfo.PropertyType.GetElementType();
            }

            // Figure out base time for references
            var refDate = DateTime.Now;
            //if (pschema.ExtensionData.TryGetValue(REF_DATE, out var refDateProperty))
            //{
            //    // TODO: In theory we should probably order the ref property before the current one.  
            //    // In English though it is likely the order will be right anyway so punt for now.
            //    var date = dc.State.GetStringValue($"form.{refDateProperty.Value<string>()}");
            //    if (date != null && DateTime.TryParse(date, out var dateValue))
            //    {
            //        refDate = dateValue;
            //    }
            //}
            object? realValue = null;
            switch (propertyType)
            {
                case Type _ when propertyType == typeof(string):
                    realValue = value.Trim();
                    if (!Validator.TryValidateProperty(realValue, context, validationResults))
                        return (null, GetErrorMessage(value, propertyInfo, validationResults));
                    return (realValue, null);
                case Type _ when propertyType == typeof(bool):
                case Type _ when propertyType == typeof(bool?):
                    realValue = RecognizeBool(propertyInfo, value, "en-us");
                    if (!Validator.TryValidateProperty(realValue, context, validationResults))
                        return (null, GetErrorMessage(value, propertyInfo, validationResults));
                    return (realValue, null);
                case Type _ when propertyType == typeof(Int16):
                case Type _ when propertyType == typeof(Int16?):
                case Type _ when propertyType == typeof(Int32):
                case Type _ when propertyType == typeof(Int32?):
                case Type _ when propertyType == typeof(Int64):
                case Type _ when propertyType == typeof(Int64?):
                case Type _ when propertyType == typeof(UInt16):
                case Type _ when propertyType == typeof(UInt16?):
                case Type _ when propertyType == typeof(UInt32):
                case Type _ when propertyType == typeof(UInt32?):
                case Type _ when propertyType == typeof(UInt64):
                case Type _ when propertyType == typeof(UInt64?):
                case Type _ when propertyType == typeof(Single):
                case Type _ when propertyType == typeof(Single?):
                case Type _ when propertyType == typeof(Double):
                case Type _ when propertyType == typeof(Double?):
                    realValue = RecognizeNumber(propertyInfo, value, "en-us");
                    if (!Validator.TryValidateProperty(realValue, context, validationResults))
                        return (null, GetErrorMessage(value, propertyInfo, validationResults));
                    return (realValue, null);

                case Type _ when propertyType == typeof(DateTimeOffset):
                    {
                        var (timex, dates, times) = RecognizeTimex(propertyInfo, value, locale, refDate);
                        realValue = timex.Merge((DateTimeOffset)propertyInfo.GetValue(this.Model));
                        if (!Validator.TryValidateProperty(realValue, context, validationResults))
                        {
                            foreach (var date in dates)
                            {
                                foreach (var time in times)
                                {
                                    realValue = new DateTimeOffset(date.Year, date.Month, date.Day, time.Hour, time.Minute, time.Second, TimeSpan.MinValue);
                                }
                            }
                            return (null, GetErrorMessage(value, propertyInfo, validationResults));
                        }
                    }
                    return (realValue, null);
                case Type _ when propertyType == typeof(DateTimeOffset?):
                    {
                        var (timex, dates, times) = RecognizeTimex(propertyInfo, value, locale, refDate);
                        realValue = timex.Merge((DateTimeOffset?)propertyInfo.GetValue(this.Model));
                        if (!Validator.TryValidateProperty(realValue, context, validationResults))
                            return (null, GetErrorMessage(value, propertyInfo, validationResults));
                    }
                    return (realValue, null);
                case Type _ when propertyType == typeof(DateTime):
                    {
                        var (timex, dates, times) = RecognizeTimex(propertyInfo, value, locale, refDate);
                        realValue = timex.Merge((DateTime)propertyInfo.GetValue(this.Model));
                        if (!Validator.TryValidateProperty(realValue, context, validationResults))
                            return (null, GetErrorMessage(value, propertyInfo, validationResults));
                    }
                    return (realValue, null);
                case Type _ when propertyType == typeof(DateTime?):
                    {
                        var (timex, dates, times) = RecognizeTimex(propertyInfo, value, locale, refDate);
                        realValue = timex.Merge((DateTime?)propertyInfo.GetValue(this.Model));
                        if (!Validator.TryValidateProperty(realValue, context, validationResults))
                            return (null, GetErrorMessage(value, propertyInfo, validationResults));
                    }
                    return (realValue, null);
                case Type _ when propertyType == typeof(TimeOnly):
                    {
                        var (timex, dates, times) = RecognizeTimex(propertyInfo, value, locale, refDate);
                        realValue = timex.Merge((TimeOnly)propertyInfo.GetValue(this.Model));
                        if (!Validator.TryValidateProperty(realValue, context, validationResults))
                            return (null, GetErrorMessage(value, propertyInfo, validationResults));
                    }
                    return (realValue, null);
                case Type _ when propertyType == typeof(TimeOnly?):
                    {
                        var (timex, dates, times) = RecognizeTimex(propertyInfo, value, locale, refDate);
                        realValue = timex.Merge((TimeOnly?)propertyInfo.GetValue(this.Model));
                        if (!Validator.TryValidateProperty(realValue, context, validationResults))
                            return (null, GetErrorMessage(value, propertyInfo, validationResults));
                    }
                    return (realValue, null);
                case Type _ when propertyType == typeof(DateOnly):
                    {
                        var (timex, dates, times) = RecognizeTimex(propertyInfo, value, locale, refDate);
                        realValue = timex.Merge((DateOnly)propertyInfo.GetValue(this.Model));
                        if (!Validator.TryValidateProperty(realValue, context, validationResults))
                            return (null, GetErrorMessage(value, propertyInfo, validationResults));
                    }
                    return (realValue, null);
                case Type _ when propertyType == typeof(DateOnly?):
                    {
                        var (timex, dates, times) = RecognizeTimex(propertyInfo, value, locale, refDate);
                        realValue = timex.Merge((DateOnly?)propertyInfo.GetValue(this.Model));
                        if (!Validator.TryValidateProperty(realValue, context, validationResults))
                            return (null, GetErrorMessage(value, propertyInfo, validationResults));
                    }
                    return (realValue, null);

                ////case "duration":
                ////    {
                ////        var (type, timex, _dvalue) = RecognizeDateTime(pschema, value, locale, refDate);
                ////        TimexProperty timexProperty = new TimexProperty(timex);
                ////    }
                ////    break;
                default:
                    //{
                    //    var enumChoices = pschema!.Enum;
                    //    if (enumChoices.Any())
                    //    {
                    //        var nvalue = Normalize(value);
                    //        var wordCount = -1;
                    //        List<string>? wordMatches = null;
                    //        foreach (var jchoice in enumChoices)
                    //        {
                    //            var choice = jchoice.ToString();
                    //            if (choice.ToLowerInvariant() == nvalue)
                    //            {
                    //                result = choice;
                    //                break;
                    //            }
                    //            else
                    //            {
                    //                // Break on case changes and normalize
                    //                var words = from word in Regex.Split(choice, @"(?<!^)(?=\p{Lu})") select Normalize(word);
                    //                var phrase = string.Join(' ', words);
                    //                if (phrase == nvalue)
                    //                {
                    //                    result = choice;
                    //                    break;
                    //                }
                    //                else
                    //                {
                    //                    // Count word matches for partial matches
                    //                    var count = 0;
                    //                    foreach (var word in words)
                    //                    {
                    //                        if (nvalue.Contains(word))
                    //                        {
                    //                            ++count;
                    //                        }
                    //                    }
                    //                    if (count == wordCount)
                    //                    {
                    //                        wordMatches!.Add(choice);
                    //                    }
                    //                    else if (count > 0 && count > wordCount)
                    //                    {
                    //                        wordCount = count;
                    //                        wordMatches = new List<string> { choice };
                    //                    }
                    //                }
                    //            }
                    //        }
                    //        if (wordMatches != null && wordMatches.Count == 1)
                    //        {
                    //            // Partial match of one choice
                    //            result = wordMatches.First();
                    //        }
                    //    }
                    //    else
                    //    {
                    //        result = value;
                    //    }
                    //}
                    break;
            }
            return (null, "uhoho");
        }

        private static string GetErrorMessage(string value, PropertyInfo propertyInfo, List<ValidationResult> validationResults)
        {
            return $"{value} is not valid for {propertyInfo.GetPropertyLabel()} because: {string.Join(',', validationResults.Select(e => e.ErrorMessage))}";
        }

        static protected (TimexProperty, IList<DateOnly>, IList<TimeOnly>) RecognizeTimex(PropertyInfo propertyInfo, string value, string locale, DateTime refDate)
        {
            var results = DateTimeRecognizer.RecognizeDateTime(value, locale, refTime: refDate);
            if (results == null)
            {
                results = NumberRecognizer.RecognizeOrdinal(value, locale);
                if (results != null)
                {
                    results = DateTimeRecognizer.RecognizeDateTime($"on the {value}", "en-us", refTime: refDate);
                }
            }

            TimexProperty? timexProperty = null;
            List<DateOnly> dates = new List<DateOnly>();
            List<TimeOnly> times = new List<TimeOnly>();
            if (results != null)
            {
                foreach (var values in results[0].Resolution["values"] as List<Dictionary<string, string>>)
                {
                    if (timexProperty == null && values.ContainsKey("timex"))
                    {
                        timexProperty = new TimexProperty(values["timex"]);
                    }

                    if (values.ContainsKey("type"))
                    {
                        var valueType = values["type"];
                        var val = values["value"];
                        if (valueType == "datetime")
                        {
                            var dt = DateTime.Parse(val);
                            dates.Add(DateOnly.FromDateTime(dt));
                            times.Add(TimeOnly.FromDateTime(dt));
                        }
                        else if (valueType == "date")
                        {
                            dates.Add(DateOnly.Parse(val));
                        }
                        else if (valueType == "time")
                        {
                            times.Add(TimeOnly.Parse(val));
                        }
                    }
                }
            }
            return (timexProperty, dates, times.Distinct().ToList());
        }

        static protected object? RecognizeNumber(PropertyInfo propertyInfo, string value, string locale)
        {
            object? result = null;
            value = value.Trim();

            var models = NumberRecognizer.RecognizeNumber(value, locale);
            if (models.Count > 1)
            {
                return null;
            }
            var model = models.FirstOrDefault();
            if (model != null)
            {
                var subtype = model.Resolution["subtype"] as string;
                var svalue = model.Resolution["value"] as string;
                if (subtype != null && svalue != null)
                {
                    if (model.Start == 0 && model.End == 0)
                    {
                        model.Start = value.IndexOf(svalue);
                        model.End = svalue.Length;
                    }

                    if ((model.End - model.Start) >= value.Length / 2)
                    {

                        if (subtype == Microsoft.Recognizers.Text.Number.Constants.INTEGER)
                        {
                            if (int.TryParse(svalue, out var ivalue))
                            {
                                result = ivalue;
                            }
                        }
                        else
                        {
                            // DECIMAL, FRACTION or POWER
                            if (double.TryParse(svalue, out var dvalue))
                            {
                                result = dvalue;
                            }
                        }
                    }
                }
            }

            if (result != null)
            {
                var targetType = propertyInfo.PropertyType;
                if (targetType.GenericTypeArguments.Any())
                    targetType = targetType.GenericTypeArguments.First();
                return Convert.ChangeType(result, targetType);
            }
            return result;
        }

        static protected bool? RecognizeBool(PropertyInfo propertyInfo, string value, string locale)
        {
            object? result = null;
            value = value.Trim();

            var models = ChoiceRecognizer.RecognizeBoolean(value, locale);
            if (models.Count > 1)
            {
                return null;
            }
            var model = models.FirstOrDefault();
            if (model != null)
            {
                return (bool?)model.Resolution["value"];
            }
            return null;
        }

        protected string GetPropertyForLabel(string propertyRef)
        {
            if (string.IsNullOrEmpty(propertyRef))
            {
                return null;
            }

            if (this.Model.GetType().HasProperty(propertyRef))
            {
                return propertyRef;
            }

            foreach (var propertyInfo in this.Model.GetType().GetProperties())
            {
                if (String.Equals(propertyInfo.GetPropertyLabel(), propertyRef, StringComparison.OrdinalIgnoreCase))
                {
                    return propertyInfo.Name;
                }
            }
            return propertyRef;
        }
        #endregion
    }
}
